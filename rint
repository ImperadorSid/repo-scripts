Time	Sum	Command
1253	30247	> builtin source /usr/share/fish/config.fish
27	27	-> set -g IFS \n\ \t
7	7	-> set -qg __fish_added_user_paths
10	10	-> set -g __fish_added_user_paths
3	10	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
7	7	--> not set -q __fish_initialized
7	7	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
7	22	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
7	7	--> status --is-interactive
8	8	--> function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    ...
9	9	-> set -l __extra_completionsdir
8	8	-> set -l __extra_functionsdir
8	8	-> set -l __extra_confdir
8	139	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
26	26	--> test -f $__fish_data_dir/__fish_build_paths.fish
77	105	--> source $__fish_data_dir/__fish_build_paths.fish
13	13	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
8	8	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
7	7	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
7	7	-> set -l xdg_data_dirs
7	234	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
5	5	--> set -q XDG_DATA_DIRS
13	13	--> set --path xdg_data_dirs $XDG_DATA_DIRS
128	209	--> set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
81	81	---> string replace -r '([^/])/$' '$1' -- $xdg_data_dirs
19	19	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
15	15	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
14	14	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
3	21	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
18	18	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
3	20	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
17	17	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
4	19	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
15	15	--> not contains -- $__extra_confdir $vendor_confdirs
7	43	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
7	7	--> not set -q fish_function_path
29	29	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
9	45	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
7	7	--> not set -q fish_complete_path
29	29	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
10	10	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
2	31	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
6	29	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
9	9	---> not set -q FISH_UNIT_TESTS_RUNNING
14	14	---> test -d /usr/xpg4/bin
12	12	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
15	15	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
6	6	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
142	707	-> __fish_set_locale
455	464	--> source /usr/share/fish/functions/__fish_set_locale.fish
9	9	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
13	13	--> set -l LOCALE_VARS
12	12	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
12	12	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
11	11	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
30	53	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
7	23	---> if set -q $locale_var
            return 0
        ...
10	10	----> set -q $locale_var
6	6	----> return 0
12	12	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
2	18	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
16	16	--> test $__fish_initialized -lt 2300
3	10	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
7	7	--> status --is-login
27	1014	-> __fish_reconstruct_path
28	28	--> set -l local_path $PATH
17	17	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
10	10	--> set -g __fish_added_user_paths
5	897	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
6	6	---> set -q fish_user_paths
97	886	---> for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        ...
73	73	----> string split ":" -- $fish_user_paths[-1..1]
7	147	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
47	123	-----> set -l idx (contains --index -- $x $local_path)
76	76	------> contains --index -- $x $local_path
17	17	-----> set -e local_path[$idx]
14	14	----> set -p local_path $x
5	94	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
41	73	-----> set -l idx (contains --index -- $x $local_path)
32	32	------> contains --index -- $x $local_path
16	16	-----> set -e local_path[$idx]
13	13	----> set -p local_path $x
5	93	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
40	71	-----> set -l idx (contains --index -- $x $local_path)
31	31	------> contains --index -- $x $local_path
17	17	-----> set -e local_path[$idx]
14	14	----> set -p local_path $x
7	95	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
41	71	-----> set -l idx (contains --index -- $x $local_path)
30	30	------> contains --index -- $x $local_path
17	17	-----> set -e local_path[$idx]
15	15	----> set -p local_path $x
7	106	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
  39	71	-----> set -l idx (contains --index -- $x $local_path)
32	32	------> contains --index -- $x $local_path
15	15	-----> set -e local_path[$idx]
13	13	----> set -p local_path $x
7	96	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
39	71	-----> set -l idx (contains --index -- $x $local_path)
32	32	------> contain-----> contains --index -- $x $local_path
16	16	-----> set -e local_path[$idx]
14	14	----> set -p local_path $x
35	35	--> set -xg PATH $local_path
6	6	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
21	51	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
7	7	--> function $jobbltn -V jobblltin $jobbltn (__fish_expand_pid_args $argv)
    ...
7	7	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
7	7	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
3	3	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
9	9	-> set -l sourcelist
157	25817	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
49	82	--> set -l basename (string replace -r '^.*/' '' -- $file)
33	33	---> string replace -r '^.*/' '' -- $file
15	15	--> contains -- $basename $sourcelist
12	12	--> set sourcelist $sourcelist $basename
24	24	--> [ -f $file -a -r $file ]
56	1432	--> source $file
58	1376	---> set -x GITHUB_TOKEN (sed -n '40p' ~/Downloads/Linux/System/Distros/additional-info.txt)
1318	1318	----> sed -n '40p' ~/Downloads/Linux/System/Distros/additional-info.txt
52	80	--> set -l basename (string replace -r '^.*/' '' -- $file)
28	28	---> string replace -r '^.*/' '' -- $file
15	15	--> contains -- $basename $sourcelist
12	12	--> set sourcelist $sourcelist $basename
22	22	--> [ -f $file -a -r $file ]
51	23966	--> source $file
15	15	---> set -gx OMF_PATH '/home/impsid/.local/omf'
316	23900	---> source $OMF_PATH/init.fish
5	14	----> if not set -q OMF_CONFIG
  set -q XDG_CONFIG_HOME; or set -l XDG_CONFIG_HOME "$HOME/.config"
  set -gx OMF_CONFIG "$XDG_CONFIG_HOME/omf"
...
9	9	-----> not set -q OMF_CONFIG
15	15	----> test -f $OMF_CONFIG/before.init.fish
33	33	----> emit perf:timer:start "Oh My Fish initialisation"
13	13	----> test -f $OMF_CONFIG/theme
29	29	----> read -l theme < $OMF_CONFIG/theme
17	17	----> set -l core_function_path $OMF_PATH/lib{,/git}
183	183	----> set -l theme_function_path {$OMF_CONFIG,$OMF_PATH}/themes*/$theme{,/functions}
36	36	----> set fish_function_path $fish_function_path[1] \
                       $core_function_path \
                       $theme_function_path \
                       $fish_function_path[2..-1]
47	47	----> emit perf:timer:start "Oh My Fish init installed packages"
158	21679	----> require --path {$OMF_PATH,$OMF_CONFIG}/pkg/*
345	352	-----> source /home/impsid/.local/omf/lib/require.fish
7	7	------> function require
  set packages $argv

  if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  end

  # If bundle should be
  if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  end

  # Requiring absolute paths
  if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  end

  set function_path $package_path/functions*
  set complete_path $package_path/completions*
  set init_path $package_path/init.fish*
  set conf_path $package_path/conf.d/*.fish

  # Autoload functions
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]

  # Autoload completions
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]

  for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  end

  for conf in $conf_path
    source $conf
  end

  return 0
...
23	23	-----> set packages $argv
4	18	-----> if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  ...
14	14	------> test -z "$packages"
4	109	-----> if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  ...
44	105	------> set index (contains -i -- --no-bundle $---> contains -i -- --no-bundle $packages
7	95	-----> if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  ...
39	59	------> set index (contains -i -- --path $packages)
20	20	-------> contains -i -- --path $packages
14	14	------> set -e packages[$index]
15	15	------> set package_path $packages
131	131	-----> set function_path $package_path/functions*
119	119	-----> set complete_path $package_path/completions*
121	121	-----> set init_path $package_path/init.fish*
133	133	-----> set conf_path $package_path/conf.d/*.fish
13	13	-----> test -n "$function_path"
33	33	-----> set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]
9	9	-----> test -n "$complete_path"
29	29	-----> set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]
84	19365	-----> for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  ...
62	62	------> emit perf:timer:start $init
10	10	------> set -l IFS '/'
106	106	------> echo $init | read -la components
50	126	------> set path (printf '/%s' $components[1..-2])
76	76	-------> printf '/%s' $components[1..-2]
63	63	------> contains $path $omf_init_path
11	11	------> set package $components[-2]
9	48	------> if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    ...
6	6	-------> not set -q ignore_bundle
11	11	-------> set bundle $path/bundle
7	7	-------> set dependencies
3	15	-------> if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      ...
12	12	--------> test -f $bundle
1--> test -f $bundle
168	539	------> source $init $path
43	61	-------> set -x LESS_TERMCAP_md (printf "\e[01;38;5;74m")
18	18	--------> printf "\e[01;38;5;74m"
43	57	-------> set -x LESS_TERMCAP_mb (printf "\033[01;31m")
14	14	--------> printf "\033[01;31m"
37	51	-------> set -x LESS_TERMCAP_me (printf "\033[0m")
14	14	--------> printf "\033[0m"
38	51	-------> set -x LESS_TERMCAP_ue (printf "\e[0m")
13	13	--------> printf "\e[0m"
38	52	-------> set -x LESS_TERMCAP_us (printf "\e[04;38;5;146m")
14	14	--------> printf "\e[04;38;5;146m"
36	49	-------> set -xntf "\033[0m")
13	13	--------> printf "\033[0m"
37	51	-------> set -x LESS_TERMCAP_so (printf "\033[01;44;33m")
14	14	--------> printf "\033[01;44;33m"
17	17	------> emit init_$package $path
13	13	------> set -g omf_init_path $omf_init_path $path
12	12	------> emit perf:timer:finish $init
11	11	------> emit perf:timer:start $init
8	8	------> set -l IFS '/'
54	54	------> echo $init | read -la components
40	66	------> set path (printf '/%s' $components[1..-2])
26	26	-------> printf '/%s' $components[1..-2]
15	15	------> contains $path $omf_init_path
10	10	------> set package $components[-2]
10	47	------> if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    ...
6	6	-------> not set -q ignore_bundle
10	10	-------> set bundle $path/bundle
6	6	-------> set dependencies
3	15	-------> if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      ...
12	12	--------> test -f $bundle
115	15309	------> source $init $path
8	15194	-------> if type -q grc
  set -l execs cat cvs df diff dig gcc g++ ls ifconfig \
               make mount mtr netstat ping ps tail traceroute \
               wdiff

  if set -q grc_plugin_execs
    set execs $grc_plugin_execs
  end

  for executable in $execs
    if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      eutable $argv
      end
    end
  end
else
  echo 'You need to install grc!'
...
128	1394	--------> type -q grc
577	589	---------> source /usr/share/fish/functions/type.fish
12	12	----------> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                             case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not f (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
8	8	---------> set -q argv[1]
20	20	---------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
37	37	---------> argparse -n type -x t,p,P $options -- $argv
4	10	---------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	----------> set -q _flag_help
8	8	---------> set -l res 1
8	8	---------> set -l mode normal
8	8	---------> set -l multet -l selection all
7	7	---------> set -l short no
6	18	---------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	----------> set -q _flag_quiet
7	7	----------> set mode quiet
6	6	---------> set -q _flag_all
5	5	---------> set -q _flag_short
5	5	---------> set -q _flag_no_functions
26	504	---------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	----------> set -l found 0
7	286	----------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-----------> test $selection != files
4	116	-----------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
112	112	------------> functions -q -- $i
3	154	-----------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
115	151	------------> contains -- $i (builtin -n)
36	36	-------------> builtin -n
9	9	----------> set -l paths
7	107	----------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-----------> test $multi != yes
40	91	-----------> set paths (command -s -- $i)
51	5s (command -s -- $i)
55	55	------------> command -s -- $i
17	58	----------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-----------> set res 0
8	8	-----------> set found 1
7	7	-----------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	18	-----------> if test $multi != yes
                continue
            ...
9	9	------------> test $multi != yes
4	4	------------> continue
4	11	----------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-----------> test $found = 0
8	8	---------> return $res
18	18	--------> set -l execs cat cvs df diff dig gcc g++ ls ifconfig \
               make mount mtr netstat ping ps tail traceroute \
               wdiff
3	10	--------> if set -q grc_plugin_execs
    set execs $grc_plugin_execs
  ...
7	7	---------> set -q grc_plugin_execs
105	13453	--------> for executable in $execs
    if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    end
  ...
5	690	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
52	671	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
35	35	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
8	8	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
6	6	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
6	6	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
19	471	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
 t -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
10	245	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
63	63	--------------> functions -q -- $i
5	160	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
121	155	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
7	108	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	92	-------------> set paths (command -s -- $i)
52	52	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	18	-------------> if test $multi != yes
                continue
            ...
9	9	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
7	7	-----------> return $res
14	14	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	623	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
51	619	----------> type -q $executable
7	7	-----------> set -q argv[1-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
4	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
5	5	------------> set -q _flag_help
7	7	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
7	20	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
8	8	------------> set mode quiet
6	6	-----------> set -q _flag_all
6	6	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
29	474	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
14	277	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
     ctions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
4	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
3	162	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
125	159	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
9	9	------------> set -l paths
7	105	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
36	89	-------------> set paths (command -s -- $i)
53	53	--------------> command -s -- $i
10	10	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
5	22	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
9	9	-------------> test $found = 0
8	8	-------------> test $mode != quiet
8	8	-----------> return $res
5	671	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
54	653	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
32	32	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
8	19	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
6	6	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
20	454	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
14	246	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
8	8	-------------> test $selection != files
3	65	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
4	159	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
121	155	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
9	9	------------> set -l paths
7	104	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
8	8	-------------> test $multi != yes
40	89	-------------> set paths (command -s -- $i)
49	49	--------------> command -s -- $i
16	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
7	7	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
7	7	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
5	675	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
54	656	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
3	8	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
5	5	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	456	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
11	245	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	67	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
64	64	--------------> functions -q -- $i
4	158	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
120	154	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
7	104	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	88	-------------> set paths (command -s -- $i)
48	48	--------------> command -s -- $i
16	57	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
8	8	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	19	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
4	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-------------> test $found = 0
8	8	-----------> return $res
14	14	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	685	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
61	668	----------> type -q $executable
8	8	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
7-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
7	7	-----------> set -l selection all
6	6	-----------> set -l short no
7	17	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
4	4	------------> set -q _flag_quiet
6	6	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	451	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
10	243	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                                        case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
8	8	-------------> test $selection != files
3	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
63	63	--------------> functions -q -- $i
5	162	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
122	157	--------------> contains -- $i (builtin -n)
35	35	---------------> builtin -n
9	9	------------> set -l paths
7	105	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
42	89	-------------> set paths (command -s -- $i)
47	47	--------------> command -s -- $i
16	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
9	9	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
        ------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
7	7	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
5	677	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
52	659	----------> type -q $executable
7	7	-----------> set -q argv[1]
20	20	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
8	8	-----------> set -l short no
9	24	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
6	6	------------> set -q _flag_quiet
9	9	------------> set mode quiet
5	5	-----------> set -q _flag_all
6	6	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
17	454	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined i                  end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                   case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
11	247	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	65	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
4	162	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
124	158	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
7	106	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	90	-------------> set paths (command -s -- $i)
50	50	--------------> command -s -- $i
16	55	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	------         case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
8	8	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	675	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
51	658	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
5	11	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	461	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

      s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
7	7	------------> set -l found 0
11	245	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
    "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                   set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
8	8	-------------> test $selection != files
4	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
4	160	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
122	156	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
12	12	------------> set -l paths
8	118	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
11	11	-------------> test $multi != yes
50	99	-------------> set paths (command -s -- $i)
49	49	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
4	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-------------> test $found = 0
7	7	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
5	1955	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
52	1936	----------> type -q $executable
7	7	-----------> set -q argv[1]
20	20	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
4	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
5	5	------------> set -q _flag_help
7	7	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
6	6	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
20	1737	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
  short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
9	1587	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
14	1569	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
102	1509	--------------> functions -q -- $i
231	1407	---------------> source /usr/share/fish/functions/ls.fish
18	1176	----------------> for opt in --color=auto -G --color -F
    if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    end
...
18	1158	-----------------> if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    ...
1094	1094	------------------> command ls $opt / >/dev/null 2>/dev/null
15	15	------------------> function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        ...
6	27	------------------> if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        ...
14	14	-------------------> [ $opt = --color=auto ]
7	7	-------------------> ! set -qx LS_COLORS
4	4	------------------> break
11	11	--------------> set res 0
7	7	--------------> set found 1
8	8	--------------> switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                ...
6	20	--------------> if test $multi != yes
                    continue
                ...
9	9	---------------> test $multi != yes
5	5	---------------> continue
8	8	-----------> return $res
14	14	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	710	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
55	692	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
8	8	-----------> set -l selection all
16	16	-----------> set -l short no
7	20	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
6	6	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
24	479	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
8	252	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
4	73	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
69	69	--------------> functions -q -- $i
4	162	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
123	158	--------------> contains -- $i (builtin -n)
35	35	---------------> builtin -n
10	10	------------> set -l paths
7	117	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
47	101	-------------> set paths (command -s -- $i)
54	54	--------------> command -s -- $i
18	57	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
9	9	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%                 printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	19	-------------> if test $multi != yes
                continue
            ...
9	9	--------------> test $multi != yes
4	4	--------------> continue
4	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-------------> test $found = 0
8	8	-----------> return $res
14	14	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	676	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
50	658	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	462	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
7	7	------------> set -l found 0
8	250	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
63	63	--------------> functions -q -- $i
4	167	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
129	163	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
7	106	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
42	90	-------------> set paths (command -s -- $i)
48	48	--------------> command -s -- $i
17	57	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	19	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
7	7	-----------> return $res
14	14	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
5	682	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
49	664	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	468	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
10	250	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	67	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
64	64	--------------> functions -q -- $i
5	164	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
123	159	--------------> contains -- $i (builtin -n)
36	36	---------------> builtin -n
9	9	------------> set -l paths
7	114	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
41	98	-------------> set paths (command -s -- $i)
57	57	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
2	10	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
8	8	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
6	681	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
50	663	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
8	8	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	466	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
10	255	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	65	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
7	171	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
128	164	--------------> contains -- $i (builtin -n)
36	36	---------------> builtin -n
10	10	------------> set -l paths
7	105	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
41	89	-------------> set paths (command -s -- $i)
48	48	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	18	-------------> if test $multi != yes
                continue
            ...
9	9	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
8	8	-----------> return $res
12	12	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
6	688	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
55	669	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
7	7	-----------> set -l multi no
8	8	-----------> set -l selection all
7	7	-----------> set -l short no
6	19	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
6	6	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
20	467	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
12	253	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
4	69	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
65	65	--------------> functions -q -- $i
4	163	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
125	159	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
6	109	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
41	94	-------------> set paths (command -s -- $i)
53	53	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	18	-------------> if test $multi != yes
                continue
            ...
9	9	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
7	7	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
5	691	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
51	673	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
8	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
4	4	------------> set -q _flag_quiet
6	6	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
21	477	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
7	7	------------> set -l found 0
12	264	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
4	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
5	177	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
128	172	--------------> contains -- $i (builtin -n)
44	44	---------------> builtin -n
10	10	------------> set -l paths
7	108	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	92	-------------> set paths (command -s -- $i)
52	52	--------------> command -s -- $i
16	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	19	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
8	8	-------------> test $found = 0
8	8	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	675	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
52	658	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
7	19	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
19	459	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
11	249	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
8	8	-------------> test $selection != files
3	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
63	63	--------------> functions -q -- $i
4	164	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
126	160	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
9	9	------------> set -l paths
7	106	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	90	-------------> set paths (command -s -- $i)
50	50	--------------> command -s -- $i
18	57	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	18	-------------> if test $multi != yes
                continue
            ...
9	9	--------------> test $multi != yes
4	4	--------------> continue
4	11	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-------------> test $found = 0
7	7	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
4	672	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
49	655	----------> type -q $executable
7	7	-----------> set -q argv[1]
21	21	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
35	35	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
8	8	-----------> set -l mode normal
8	8	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
19	456	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
13	251	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
4	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	--------------> functions -q -- $i
5	163	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
124	158	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
9	9	------------> set -l paths
7	103	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
40	87	-------------> set paths (command -s -- $i)
47	47	--------------> command -s -- $i
17	56	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
8	8	-------------> set res 0
7	7	-------------> set found 1
6	6	-------------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	18	-------------> if test $multi != yes
                continue
            ...
8	8	--------------> test $multi != yes
4	4	--------------> continue
3	10	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
7	7	-------------> test $found = 0
8	8	-----------> return $res
13	13	----------> function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      ...
3	631	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
55	628	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
34	34	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
8	8	-----------> set -l res 1
7	7	-----------> set -l mode normal
8	8	-----------> set -l multi no
7	7	-----------> set -l selection all
6	6	-----------> set -l short no
6	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
5	5	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
23	427	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
7	7	------------> set -l found 0
12	249	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	69	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
66	66	--------------> functions -q -- $i
5	159	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
120	154	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
9	9	------------> set -l paths
6	108	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
37	93	-------------> set paths (command -s -- $i)
56	56	--------------> command -s -- $i
9	9	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
4	22	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
9	9	-------------> test $found = 0
9	9	-------------> test $mode != quiet
8	8	-----------> return $res
4	622	---------> if type -q $executable
      function $executable --inherit-variable executable --wraps=$executable
        grc.wrap $executable $argv
      end
    ...
52	618	----------> type -q $executable
7	7	-----------> set -q argv[1]
19	19	-----------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
33	33	-----------> argparse -n type -x t,p,P $options -- $argv
3	9	-----------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
6	6	------------> set -q _flag_help
7	7	-----------> set -l res 1
7	7	-----------> set -l mode normal
7	7	-----------> set -l multi no
7	7	-----------> set -l selection all
7	7	-----------> set -l short no
7	18	-----------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
4	4	------------> set -q _flag_quiet
7	7	------------> set mode quiet
5	5	-----------> set -q _flag_all
5	5	-----------> set -q _flag_short
5	5	-----------> set -q _flag_no_functions
19	423	-----------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	------------> set -l found 0
14	253	------------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
9	9	-------------> test $selection != files
3	66	-------------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
63	63	--------------> functions -q -- $i
4	164	-------------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
126	160	--------------> contains -- $i (builtin -n)
34	34	---------------> builtin -n
10	10	------------> set -l paths
6	103	------------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
9	9	-------------> test $multi != yes
37	88	-------------> set paths (command -s -- $i)
51	51	--------------> command -s -- $i
9	9	------------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
4	21	------------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
9	9	-------------> test $found = 0
8	8	-------------> test $mode != quiet
7	7	-----------> return $res
17	17	------> emit init_$package $path
15	15	------> set -g omf_init_path $omf_init_path $path
13	13	------> emit perf:timer:finish $init
12	12	------> emit perf:timer:start $init
8	8	------> set -l IFS '/'
59	59	------> echo $init | read -la components
41	70	------> set path (printf '/%s' $components[1..-2])
29	29	-------> printf '/%s' $components[1..-2]
17	17	------> contains $path $omf_init_path
10	10	------> set package $components[-2]
8	49	------> if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    ...
7	7	-------> not set -q ignore_bundle
11	11	-------> set bundle $path/bundle
7	7	-------> set dependencies
3	16	-------> if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      ...
13	13	--------> test -f $bundle
131	2362	------> source $init $path
14	14	-------> set -g OMF_MISSING_ARG   1
9	9	-------> set -g OMF_UNKNOWN_OPT   2
7	7	-------> set -g OMF_INVALID_ARG   3
7	7	-------> set -g OMF_UNKNOWN_ERR   4
5	5	-------> function omf::em
  set_color cyan 2> /dev/null
...
4	4	-------> function omf::dim
  set_color 555 2> /dev/null
...
3	3	-------> function omf::err
  set_color red --bold 2> /dev/null
...
3	3	-------> function omf::under
  set_color --underline 2> /dev/null
...
3	3	-------> function omf::off
  set_color normal 2> /dev/null
...
102	2176	-------> autoload $path/functions/{compat,core,index,packages,themes,bundle,util,repo,cli,search}
303	316	--------> source /home/impsid/.local/omf/lib/autoload.fish
5	5	---------> function autoload
  switch "$argv[1]"
  case '-e' '--erase'
    test (count $argv) -ge 2
      and __autoload_erase $argv[2..-1]
      or echo "usage: autoload $argv[1] <path>..." >&2
  case "-*" "--*"
    echo "autoload: invalid option $argv[1]"
    return 1
  case '*'
    test (count $argv) -ge 1
      and __autoload_insert $argv
      or echo "usage: autoload <path>..." >&2
  end
...
4	4	---------> function __autoload_insert
  set -l function_path
  set -l complete_path
  for path in $argv
    not test -d "$path"; and continue
    set -l IFS '/'
    echo $path | read -la components
    if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    end;
  end;
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] $function_path $fish_function_path[2..-1]
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] $complete_path $fish_complete_path[2..-1]
  return 0
...
4	4	---------> function __autoload_erase
  set -l function_indexes
  set -l complete_indexes
  for path in $argv
    set -l IFS '/'
    echo $path | read -la components
    test "x$components[-1]" = xcompletions
      and set complete_indexes $complete_indexes (contains -i $path $fish_complete_path)
      or  set function_indexes $function_indexes (contains -i $path $fish_function_path)
  end;
  test -n "$function_indexes"
    and set -e fish_function_path["$function_indexes"]
  test -n "$complete_indexes"
    and set -e fish_complete_path["$complete_indexes"]
  return 0
...
18	1758	--------> switch "$argv[1]"
  case '-e' '--erase'
    test (count $argv) -ge 2
      and __autoload_erase $argv[2..-1]
      or echo "usage: autoload $argv[1] <path>..." >&2
  case "-*" "--*"
    echo "autoload: invalid option $argv[1]"
    return 1
  case '*'
    test (count $argv) -ge 1
      and __autoload_insert $argv
      or echo "usage: autoload <path>..." >&2
  ...
45	132	---------> test (count $argv) -ge 1
87	87	----------> count $argv
51	1608	---------> __autoload_insert $argv
10	10	----------> set -l function_path
7	7	----------> set -l complete_path
98	1463	----------> for path in $argv
    not test -d "$path"; and continue
    set -l IFS '/'
    echo $path | read -la components
    if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    end;
  ...
18	18	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
61	61	-----------> echo $path | read -la components
9	64	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
31	31	------------> contains -- $path $fish_function_path
13	13	------------> set function_path $function_path $path
14	14	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
57	57	-----------> echo $path | read -la components
8	64	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
31	31	------------> contains -- $path $fish_function_path
14	14	------------> set function_path $function_path $path
14	14	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
56	56	-----------> echo $path | read -la components
8	63	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
29	29	------------> contains -- $path $fish_function_path
15	15	------------> set function_path $function_path $path
14	14	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
59	59	-----------> echo $path | read -la components
9	66	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
29	29	------------> contains -- $path $fish_function_path
17	17	------------> set function_path $function_path $path
16	16	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
62	62	-----------> echo $path | read -la components
10	70	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
31	31	------------> contains -- $path $fish_function_path
18	18	------------> set function_path $function_path $path
15	15	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
60	60	-----------> echo $path | read -la components
11	72	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
10	10	------------> test "x$components[-1]" = xcompletions
31	31	------------> contains -- $path $fish_function_path
20	20	------------> set function_path $function_path $path
15	15	-----------> not test -d "$path"
8	8	-----------> set -l IFS '/'
57	57	-----------> echo $path | read -la components
7	70	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
31	31	------------> contains -- $path $fish_function_path
21	21	------------> set function_path $function_path $path
14	14	-----------> not test -d "$path"
8	8	-----------> set -l IFS '/'
57	57	-----------> echo $path | read -la components
9	69	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
11	11	------------> test "x$components[-1]" = xcompletions
30	30	------------> contains -- $path $fish_function_path
19	19	------------> set function_path $function_path $path
14	14	-----------> not test -d "$path"
9	9	-----------> set -l IFS '/'
59	59	-----------> echo $path | read -la components
9	70	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
10	10	------------> test "x$components[-1]" = xcompletions
30	30	------------> contains -- $path $fish_function_path
21	21	------------> set function_path $function_path $path
12	12	-----------> not test -d "$path"
4	4	-----------> continue
14	14	----------> test -n "$function_path"
48	48	----------> set fish_function_path $fish_function_path[1] $function_path $fish_function_path[2..-1]
9	9	----------> test -n "$complete_path"
6	6	----------> return 0
119	119	------> emit init_$package $path
17	17	------> set -g omf_init_path $omf_init_path $path
14	14	------> emit perf:timer:finish $init
23	1176	-----> for conf in $conf_path
    source $conf
  ...
236	283	------> source $conf
11	11	-------> set -q FZF_TMUX_HEIGHT
7	7	-------> set -q FZF_DEFAULT_OPTS
7	7	-------> set -q FZF_LEGACY_KEYBINDINGS
6	6	-------> set -q FZF_PREVIEW_FILE_CMD
6	6	-------> set -q FZF_PREVIEW_DIR_CMD
10	10	-------> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
266	870	------> source $conf
17	384	-------> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
    bind \ct '__fzf_find_file'
    bind \cr '__fzf_reverse_isearch'
    bind \ec '__fzf_cd'
    bind \eC '__fzf_cd --hidden'
    bind \cg '__fzf_open'
    bind \co '__fzf_open --editor'

    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \ct '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \cg '__fzf_open'
        bind -M insert \co '__fzf_open --editor'
    end
else
    bind \co '__fzf_find_file'
    bind \cr '__fzf_reverse_isearch'
    bind \ec '__fzf_cd'
    bind \eC '__fzf_cd --hidden'
    bind \eO '__fzf_open'
    bind \eo '__fzf_open --editor'

    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \co '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \eO '__fzf_open'
        bind -M insert \eo '__fzf_open --editor'
    end
...
24	24	--------> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
109	109	--------> bind \co '__fzf_find_file'
15	15	--------> bind \cr '__fzf_reverse_isearch'
14	14	--------> bind \ec '__fzf_cd'
13	13	--------> bind \eC '__fzf_cd --hidden'
14	14	--------> bind \eO '__fzf_open'
14	14	--------> bind \eo '__fzf_open --editor'
19	164	--------> if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \co '__fzf_find_file'
        bind -M insert \cr '__fzf_reverse_isearch'
        bind -M insert \ec '__fzf_cd'
        bind -M insert \eC '__fzf_cd --hidden'
        bind -M insert \eO '__fzf_open'
        bind -M insert \eo '__fzf_open --editor'
    ...
50	50	---------> bind -M insert >/dev/null 2>/dev/null
17	17	---------> bind -M insert \co '__fzf_find_file'
16	16	---------> bind -M insert \cr '__fzf_reverse_isearch'
18	18	---------> bind -M insert \ec '__fzf_cd'
15	15	---------> bind -M insert \eC '__fzf_cd --hidden'
14	14	---------> bind -M insert \eO '__fzf_open'
15	15	---------> bind -M insert \eo '__fzf_open --editor'
8	210	-------> if set -q FZF_COMPLETE
    bind \t '__fzf_complete'
    if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \t '__fzf_complete'
    end
...
9	9	--------> set -q FZF_COMPLETE
14	14	--------> bind \t '__fzf_complete'
8	179	--------> if bind -M insert >/dev/null 2>/dev/null
        bind -M insert \t '__fzf_complete'
    ...
149	149	---------> bind -M insert >/dev/null 2>/dev/null
22	22	---------> bind -M insert \t '__fzf_complete'
10	10	-------> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
6	6	-----> return 0
18	18	----> emit perf:timer:finish "Oh My Fish init installed packages"
161	228	----> functions -q fish_user_key_bindings
61	67	-----> source /home/impsid/.config/fish/functions/fish_user_key_bindings.fish
6	6	------> function fish_user_key_bindings
  bind -M insert \e, 'v /home/impsid/.config/fish/config.fish'
  bind -M insert \e. 'v /home/impsid/.config/fish/functions'
...
124	124	----> not functions -q __original_fish_user_key_bindings
22	22	----> functions -c fish_user_key_bindings __original_fish_user_key_bindings
5	5	----> function fish_user_key_bindings
  test -f $OMF_CONFIG/theme
    and read -l theme < $OMF_CONFIG/theme
    or set -l theme default
  test -e $OMF_CONFIG/key_bindings.fish;
    and source $OMF_CONFIG/key_bindings.fish
  # Prepare packages key bindings paths
  set -l key_bindings {$OMF_CONFIG,$OMF_PATH}/pkg/*/key_bindings.fish \
                      {$OMF_CONFIG,$OMF_PATH}/themes*/$theme/key_bindings.fish
  # Source all keybindings collected
  for file in $key_bindings
    source $file
  end
  # Call original key bindings if existent
  functions -q __original_fish_user_key_bindings
    and __original_fish_user_key_bindings
...
16	16	----> emit perf:timer:start "Oh My Fish init user config path"
147	1052	----> require --no-bundle --path $OMF_CONFIG
357	363	-----> source /home/impsid/.local/omf/lib/require.fish
6	6	------> function require
  set packages $argv

  if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  end

  # If bundle should be
  if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  end

  # Requiring absolute paths
  if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  end

  set function_path $package_path/functions*
  set complete_path $package_path/completions*
  set init_path $package_path/init.fish*
  set conf_path $package_path/conf.d/*.fish

  # Autoload functions
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]

  # Autoload completions
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]

  for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  end

  for conf in $conf_path
    source $conf
  end

  return 0
...
17	17	-----> set packages $argv
3	15	-----> if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  ...
12	12	------> test -z "$packages"
7	221	-----> if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  ...
52	187	------> set index (contains -i -- --no-bundle $packages)
135	135	-------> contains -i -- --no-bundle $packages
18	18	------> set -e packages[$index]
9	9	------> set ignore_bundle
8	99	-----> if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  ...
44	66	------> set index (contains -i -- --path $packages)
22	22	-------> contains -i -- --path $packages
14	14	------> set -e packages[$index]
11	11	------> set package_path $packages
49	49	-----> set function_path $package_path/functions*
32	32	-----> set complete_path $package_path/completions*
30	30	-----> set init_path $package_path/init.fish*
34	34	-----> set conf_path $package_path/conf.d/*.fish
10	10	-----> test -n "$function_path"
8	8	-----> test -n "$complete_path"
12	12	-----> for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  ...
9	9	-----> for conf in $conf_path
    source $conf
  ...
6	6	-----> return 0
16	16	----> emit perf:timer:finish "Oh My Fish init user config path"
131	131	----> set -l theme_conf_path {$OMF_CONFIG,$OMF_PATH}/themes*/$theme/conf.d
11	11	----> for conf in $theme_conf_path/*.fish
  source $conf
...
16	16	----> emit perf:timer:finish "Oh My Fish initialisation"
48	48	> builtin source /etc/fish/config.fish
254	22735	> builtin source /home/impsid/.config/fish/config.fish
13	13	-> set -x EDITOR vim
10	10	-> set -x BROWSER google-chrome
9	9	-> set -x MAKEFLAGS j 12
16	16	-> set -x repositories ~/Downloads/Linux/System/Repositories
12	12	-> set -x dotfiles $repositories/dotfiles
12	12	-> set -x system_files $repositories/system-files
13	13	-> set -x tasks_file ~/Documents/Books/Tasks/tasks.json
9	9	-> set -g theme_display_date no
8	8	-> set -g theme_nerd_fonts yes
8	8	-> set -g theme_color_scheme dracula
195	1597	-> alias a  'apt'
365	377	--> source /usr/share/fish/functions/alias.fish
12	12	---> function alias --description 'Creates a function wrapping a command'
    set -l options 'h/help' 's/save'
    argparse -n alias --max-args=2 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help alias
        return 0
    end

    set -l name
    set -l body
    set -l prefix
    set -l first_word
    set -l wrapped_cmd

    if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    end

    # sanity check
    if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    end

    # Extract the first command from the body.
    printf '%s\n' $body | read -lt first_word body

    # Prevent the alias from immediately running into an infinite recursion if
    # $body starts with the same command as $name.
    if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    end
    set -l cmd_string (string escape -- "alias $argv")
    set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
    echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
    if set -q _flag_save
        funcsave $name
    end
    #echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end"
...
13	13	--> set -l options 'h/help' 's/save'
22	22	--> argparse -n alias --max-args=2 $options -- $argv
3	10	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
7	7	---> set -q _flag_help
7	7	--> set -l name
7	7	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
11	41	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
5	5	---> not set -q argv[2]
10	10	---> set name $argv[1]
8	8	---> set body $argv[2]
4	21	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
10	10	---> test -z "$name"
7	7	---> test -z "$body"
137	137	--> printf '%s\n' $body | read -lt first_word body
3	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
12	12	---> test $first_word = $name
49	162	--> set -l cmd_string (string escape -- "alias $argv")
113	113	---> string escape -- "alias $argv"
108	279	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
171	171	---> string join ' ' -- $first_word $body | string escape
254	273	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
19	19	---> function a --wraps apt --description 'alias a apt';  apt  $argv; ...
5	17	--> if set -q _flag_save
        funcsave $name
    ...
12	12	---> set -q _flag_save
68	776	-> alias a2 'aria2c'
17	17	--> set -l options 'h/help' 's/save'
31	31	--> argparse -n alias --max-args=2 $options -- $argv
4	12	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
8	8	---> set -q _flag_help
11	11	--> set -l name
9	9	--> set -l body
9	9	--> set -l prefix
10	10	--> set -l first_word
9	9	--> set -l wrapped_cmd
13	56	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
9	9	---> not set -q argv[1]
8	8	---> not set -q argv[2]
14	14	---> set name $argv[1]
12	12	---> set body $argv[2]
5	30	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
14	14	---> test -z "$name"
11	11	---> test -z "$body"
69	69	--> printf '%s\n' $body | read -lt first_word body
4	21	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
17	17	---> test $first_word = $name
71	101	--> set -l cmd_string (string escape -- "alias $argv")
30	30	---> string escape -- "alias $argv"
77	204	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
127	127	---> string join ' ' -- $first_word $body | string escape
94	108	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
14	14	---> function a2 --wraps aria2c --description 'alias a2 aria2c';  aria2c  $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
55	673	-> alias c  'clear; tmux clear-history'
12	12	--> set -l options 'h/help' 's/save'
22	22	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
7	7	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
10	41	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
6	6	---> not set -q argv[2]
10	10	---> set name $argv[1]
9	9	---> set body $argv[2]
4	21	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
9	9	---> test -z "$name"
8	8	---> test -z "$body"
58	58	--> printf '%s\n' $body | read -lt first_word body
3	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
12	12	---> test $first_word = $name
46	69	--> set -l cmd_string (string escape -- "alias $argv")
23	23	---> string escape -- "alias $argv"
82	192	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
110	110	---> string join ' ' -- $first_word $body | string escape
120	133	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
13	13	---> function c --wraps 'clear ; tmux clear-history' --description 'alias c clear; tmux clear-history';  clear ; tmux clear-history $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
47	587	-> alias g  'git'
12	12	--> set -l options 'h/help' 's/save'
20	20	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
10	39	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
5	5	---> not set -q argv[2]
10	10	---> set name $argv[1]
8	8	---> set body $argv[2]
5	21	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
8	8	---> test -z "$name"
8	8	---> test -z "$body"
55	55	--> printf '%s\n' $body | read -lt first_word body
3	16	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
53	78	--> set -l cmd_string (string escape -- "alias $argv")
25	25	---> string escape -- "alias $argv"
52	146	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
94	94	---> string join ' ' -- $first_word $body | string escape
88	99	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
11	11	---> function g --wraps git --description 'alias g git';  git  $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
51	564	-> alias i  'ipython'
11	11	--> set -l options 'h/help' 's/save'
20	20	--> argparse -n alias --max-args=2 $options -- $argv
2	8	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
9	39	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
6	6	---> not set -q argv[2]
10	10	---> set name $argv[1]
8	8	---> set body $argv[2]
5	21	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
9	9	---> test -z "$name"
7	7	---> test -z "$body"
58	58	--> printf '%s\n' $body | read -lt first_word body
3	17	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
14	14	---> test $first_word = $name
53	74	--> set -l cmd_string (string escape -- "alias $argv")
21	21	---> string escape -- "alias $argv"
50	129	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
79	79	---> string join ' ' -- $first_word $body | string escape
81	92	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
11	11	---> function i --wraps ipython --description 'alias i ipython';  ipython  $argv; ...
3	10	--> if set -q _flag_save
        funcsave $name
    ...
7	7	---> set -q _flag_save
48	521	-> alias j  'jupyter lab'
11	11	--> set -l options 'h/help' 's/save'
20	20	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
6	6	--> set -l prefix
7	7	--> set -l first_word
6	6	--> set -l wrapped_cmd
11	39	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
5	5	---> not set -q argv[2]
9	9	---> set name $argv[1]
8	8	---> set body $argv[2]
4	20	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
8	8	---> test -z "$name"
8	8	---> test -z "$body"
48	48	--> printf '%s\n' $body | read -lt first_word body
4	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
11	11	---> test $first_word = $name
43	67	--> set -l cmd_string (string escape -- "alias $argv")
24	24	---> string escape -- "alias $argv"
44	108	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
64	64	---> string join ' ' -- $first_word $body | string escape
81	93	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
12	12	---> function j --wraps 'jupyter lab' --description 'alias j jupyter lab';  jupyter lab $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
70	859	-> alias m  'man'
11	11	--> set -l options 'h/help' 's/save'
19	19	--> argparse -n alias --max-args=2 $options -- $argv
4	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
5	5	---> set -q _flag_help
7	7	--> set -l name
7	7	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
6	6	--> set -l wrapped_cmd
11	39	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
5	5	---> not set -q argv[2]
9	9	---> set name $argv[1]
8	8	---> set body $argv[2]
5	21	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
9	9	---> test -z "$name"
7	7	---> test -z "$body"
44	44	--> printf '%s\n' $body | read -lt first_word body
3	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
12	12	---> test $first_word = $name
45	65	--> set -l cmd_string (string escape -- "alias $argv")
20	20	---> string escape -- "alias $argv"
105	194	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
89	89	---> string join ' ' -- $first_word $body | string escape
262	297	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
35	35	---> function m --wraps man --description 'alias m man';  man  $argv; ...
13	41	--> if set -q _flag_save
        funcsave $name
    ...
28	28	---> set -q _flag_save
171	1684	-> alias n  'npm'
55	55	--> set -l options 'h/help' 's/save'
69	69	--> argparse -n alias --max-args=2 $options -- $argv
9	32	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
23	23	---> set -q _flag_help
26	26	--> set -l name
24	24	--> set -l body
25	25	--> set -l prefix
26	26	--> set -l first_word
25	25	--> set -l wrapped_cmd
33	142	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
22	22	---> not set -q argv[1]
20	20	---> not set -q argv[2]
36	36	---> set name $argv[1]
31	31	---> set body $argv[2]
18	76	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
32	32	---> test -z "$name"
26	26	---> test -z "$body"
133	133	--> printf '%s\n' $body | read -lt first_word body
11	51	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
40	40	---> test $first_word = $name
127	201	--> set -l cmd_string (string escape -- "alias $argv")
74	74	---> string escape -- "alias $argv"
154	332	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
178	178	---> string join ' ' -- $first_word $body | string escape
229	261	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
32	32	---> function n --wraps npm --description 'alias n npm';  npm  $argv; ...
10	35	--> if set -q _flag_save
        funcsave $name
    ...
25	25	---> set -q _flag_save
139	1105	-> alias N  'node'
41	41	--> set -l options 'h/help' 's/save'
63	63	--> argparse -n alias --max-args=2 $options -- $argv
11	32	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
21	21	---> set -q _flag_help
24	24	--> set -l name
22	22	--> set -l body
23	23	--> set -l prefix
23	23	--> set -l first_word
23	23	--> set -l wrapped_cmd
33	141	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
21	21	---> not set -q argv[1]
19	19	---> not set -q argv[2]
36	36	---> set name $argv[1]
32	32	---> set body $argv[2]
16	74	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
32	32	---> test -z "$name"
26	26	---> test -z "$body"
129	129	--> printf '%s\n' $body | read -lt first_word body
6	26	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
20	20	---> test $first_word = $name
59	85	--> set -l cmd_string (string escape -- "alias $argv")
26	26	---> string escape -- "alias $argv"
65	148	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
83	83	---> string join ' ' -- $first_word $body | string escape
91	102	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
11	11	---> function N --wraps node --description 'alias N node';  node  $argv; ...
3	10	--> if set -q _flag_save
        funcsave $name
    ...
7	7	---> set -q _flag_save
58	554	-> alias p  'personal_script'
11	11	--> set -l options 'h/help' 's/save'
20	20	--> argparse -n alias --max-args=2 $options -- $argv
3	8	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
5	5	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
6	6	--> set -l prefix
7	7	--> set -l first_word
6	6	--> set -l wrapped_cmd
10	40	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
5	5	---> not set -q argv[2]
10	10	---> set name $argv[1]
9	9	---> set body $argv[2]
5	22	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
10	10	---> test -z "$name"
7	7	---> test -z "$body"
50	50	--> printf '%s\n' $body | read -lt first_word body
3	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
12	12	---> test $first_word = $name
45	68	--> set -l cmd_string (string escape -- "alias $argv")
23	23	---> string escape -- "alias $argv"
54	128	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
74	74	---> string join ' ' -- $first_word $body | string escape
82	92	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
10	10	---> function p --wraps personal_script --description 'alias p personal_script';  personal_script  $argv; ...
3	10	--> if set -q _flag_save
        funcsave $name
    ...
7	7	---> set -q _flag_save
54	631	-> alias r  'repos'
10	10	--> set -l options 'h/help' 's/save'
19	19	--> argparse -n alias --max-args=2 $options -- $argv
2	7	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
5	5	---> set -q _flag_help
6	6	--> set -l name
6	6	--> set -l body
6	6	--> set -l prefix
6	6	--> set -l first_word
6	6	--> set -l wrapped_cmd
8	34	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
4	4	---> not set -q argv[2]
9	9	---> set name $argv[1]
7	7	---> set body $argv[2]
5	19	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
8	8	---> test -z "$name"
6	6	---> test -z "$body"
42	42	--> printf '%s\n' $body | read -lt first_word body
3	14	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
11	11	---> test $first_word = $name
61	84	--> set -l cmd_string (string escape -- "alias $argv")
23	23	---> string escape -- "alias $argv"
67	133	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
66	66	---> string join ' ' -- $first_word $body | string escape
144	163	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
19	19	---> function r --wraps repos --description 'alias r repos';  repos  $argv; ...
7	22	--> if set -q _flag_save
        funcsave $name
    ...
15	15	---> set -q _flag_save
113	1380	-> alias sc 'sudo systemctl'
25	25	--> set -l options 'h/help' 's/save'
37	37	--> argparse -n alias --max-args=2 $options -- $argv
6	18	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
12	12	---> set -q _flag_help
13	13	--> set -l name
13	13	--> set -l body
14	14	--> set -l prefix
13	13	--> set -l first_word
13	13	--> set -l wrapped_cmd
20	83	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
12	12	---> not set -q argv[1]
11	11	---> not set -q argv[2]
21	21	---> set name $argv[1]
19	19	---> set body $argv[2]
11	45	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
19	19	---> test -z "$name"
15	15	---> test -z "$body"
109	109	--> printf '%s\n' $body | read -lt first_word body
12	52	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
40	40	---> test $first_word = $name
136	204	--> set -l cmd_string (string escape -- "alias $argv")
68	68	---> string escape -- "alias $argv"
124	304	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
180	180	---> string join ' ' -- $first_word $body | string escape
238	272	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
34	34	---> function sc --wraps 'sudo systemctl' --description 'alias sc sudo systemctl';  sudo systemctl $argv; ...
12	52	--> if set -q _flag_save
        funcsave $name
    ...
40	40	---> set -q _flag_save
156	1558	-> alias t  'tasks'
41	41	--> set -l options 'h/help' 's/save'
61	61	--> argparse -n alias --max-args=2 $options -- $argv
10	30	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
20	20	---> set -q _flag_help
23	23	--> set -l name
22	22	--> set -l body
23	23	--> set -l prefix
24	24	--> set -l first_word
23	23	--> set -l wrapped_cmd
32	136	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
20	20	---> not set -q argv[1]
19	19	---> not set -q argv[2]
34	34	---> set name $argv[1]
31	31	---> set body $argv[2]
16	73	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
31	31	---> test -z "$name"
26	26	---> test -z "$body"
132	132	--> printf '%s\n' $body | read -lt first_word body
11	51	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
40	40	---> test $first_word = $name
119	192	--> set -l cmd_string (string escape -- "alias $argv")
73	73	---> string escape -- "alias $argv"
119	281	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
162	162	---> string join ' ' -- $first_word $body | string escape
226	256	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
30	30	---> function t --wraps tasks --description 'alias t tasks';  tasks  $argv; ...
10	34	--> if set -q _flag_save
        funcsave $name
    ...
24	24	---> set -q _flag_save
154	1540	-> alias v  'vim'
41	41	--> set -l options 'h/help' 's/save'
61	61	--> argparse -n alias --max-args=2 $options -- $argv
10	30	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
20	20	---> set -q _flag_help
22	22	--> set -l name
22	22	--> set -l body
23	23	--> set -l prefix
23	23	--> set -l first_word
22	22	--> set -l wrapped_cmd
32	135	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
20	20	---> not set -q argv[1]
18	18	---> not set -q argv[2]
34	34	---> set name $argv[1]
31	31	---> set body $argv[2]
16	69	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
30	30	---> test -z "$name"
23	23	---> test -z "$body"
123	123	--> printf '%s\n' $body | read -lt first_word body
11	50	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
39	39	---> test $first_word = $name
128	191	--> set -l cmd_string (string escape -- "alias $argv")
63	63	---> string escape -- "alias $argv"
117	285	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
168	168	---> string join ' ' -- $first_word $body | string escape
224	255	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
31	31	---> function v --wraps vim --description 'alias v vim';  vim  $argv; ...
10	34	--> if set -q _flag_save
        funcsave $name
    ...
24	24	---> set -q _flag_save
158	1628	-> alias V  'sudo (which vim)'
39	39	--> set -l options 'h/help' 's/save'
61	61	--> argparse -n alias --max-args=2 $options -- $argv
9	29	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
20	20	---> set -q _flag_help
23	23	--> set -l name
22	22	--> set -l body
22	22	--> set -l prefix
22	22	--> set -l first_word
22	22	--> set -l wrapped_cmd
29	134	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
21	21	---> not set -q argv[1]
18	18	---> not set -q argv[2]
34	34	---> set name $argv[1]
32	32	---> set body $argv[2]
16	71	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
30	30	---> test -z "$name"
25	25	---> test -z "$body"
143	143	--> printf '%s\n' $body | read -lt first_word body
11	51	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
40	40	---> test $first_word = $name
121	204	--> set -l cmd_string (string escape -- "alias $argv")
83	83	---> string escape -- "alias $argv"
121	306	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
185	185	---> string join ' ' -- $first_word $body | string escape
252	286	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
34	34	---> function V --wraps 'sudo (which vim)' --description 'alias V sudo (which vim)';  sudo (which vim) $argv; ...
11	35	--> if set -q _flag_save
        funcsave $name
    ...
24	24	---> set -q _flag_save
159	1540	-> alias vf 'vifm'
38	38	--> set -l options 'h/help' 's/save'
60	60	--> argparse -n alias --max-args=2 $options -- $argv
10	30	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
20	20	---> set -q _flag_help
23	23	--> set -l name
22	22	--> set -l body
23	23	--> set -l prefix
23	23	--> set -l first_word
22	22	--> set -l wrapped_cmd
32	137	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
21	21	---> not set -q argv[1]
18	18	---> not set -q argv[2]
34	34	---> set name $argv[1]
32	32	---> set body $argv[2]
18	74	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
31	31	---> test -z "$name"
25	25	---> test -z "$body"
125	125	--> printf '%s\n' $body | read -lt first_word body
12	51	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
39	39	---> test $first_word = $name
120	183	--> set -l cmd_string (string escape -- "alias $argv")
63	63	---> string escape -- "alias $argv"
116	283	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
167	167	---> string join ' ' -- $first_word $body | string escape
220	252	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
32	32	---> function vf --wraps vifm --description 'alias vf vifm';  vifm  $argv; ...
11	35	--> if set -q _flag_save
        funcsave $name
    ...
24	24	---> set -q _flag_save
145	1211	-> alias x  'xclip -selection clipboard'
41	41	--> set -l options 'h/help' 's/save'
63	63	--> argparse -n alias --max-args=2 $options -- $argv
9	30	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
21	21	---> set -q _flag_help
24	24	--> set -l name
22	22	--> set -l body
22	22	--> set -l prefix
24	24	--> set -l first_word
22	22	--> set -l wrapped_cmd
32	137	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
21	21	---> not set -q argv[1]
18	18	---> not set -q argv[2]
34	34	---> set name $argv[1]
32	32	---> set body $argv[2]
16	73	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
31	31	---> test -z "$name"
26	26	---> test -z "$body"
157	157	--> printf '%s\n' $body | read -lt first_word body
8	43	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
35	35	---> test $first_word = $name
63	90	--> set -l cmd_string (string escape -- "alias $argv")
27	27	---> string escape -- "alias $argv"
74	174	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
100	100	---> string join ' ' -- $first_word $body | string escape
116	132	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
16	16	---> function x --wraps 'xclip -selection clipboard' --description 'alias x xclip -selection clipboard';  xclip -selection clipboard $argv; ...
4	12	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
59	678	-> alias echo_err 'set_color brred; echo -n "ERROR: "; set_color normal; echo'
14	14	--> set -l options 'h/help' 's/save'
24	24	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
7	7	--> set -l body
7	7	--> set -l prefix
8	8	--> set -l first_word
8	8	--> set -l wrapped_cmd
10	45	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
8	8	---> not set -q argv[1]
6	6	---> not set -q argv[2]
11	11	---> set name $argv[1]
10	10	---> set body $argv[2]
5	25	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
11	11	---> test -z "$name"
9	9	---> test -z "$body"
78	78	--> printf '%s\n' $body | read -lt first_word body
4	18	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
14	14	---> test $first_word = $name
52	80	--> set -l cmd_string (string escape -- "alias $argv")
28	28	---> string escape -- "alias $argv"
58	146	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
88	88	---> string join ' ' -- $first_word $body | string escape
117	131	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
14	14	---> function echo_err --wraps 'set_color brred; echo -n "ERROR: "; set_color normal; echo' --description 'alias echo_err set_color brred; echo -n "ERROR: "; set_color normal; echo';  set_color brred; echo -n "ERROR: "; set_color normal; echo $argv; ...
4	12	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
63	914	-> alias fd 'fd -IHL --ignore-file ~/.config/fd/index-excludes'
11	11	--> set -l options 'h/help' 's/save'
20	20	--> argparse -n alias --max-args=2 $options -- $argv
4	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
5	5	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
11	44	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
6	6	---> not set -q argv[2]
11	11	---> set name $argv[1]
9	9	---> set body $argv[2]
5	24	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
11	11	---> test -z "$name"
8	8	---> test -z "$body"
75	75	--> printf '%s\n' $body | read -lt first_word body
7	241	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
8	221	---> if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        ...
150	202	----> contains $name (builtin --names)
52	52	-----> builtin --names
11	11	----> set prefix command
54	80	--> set -l cmd_string (string escape -- "alias $argv")
26	26	---> string escape -- "alias $argv"
69	185	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
116	116	---> string join ' ' -- $first_word $body | string escape
105	118	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
13	13	---> function fd --wraps 'fd -IHL --ignore-file ~/.config/fd/index-excludes' --description 'alias fd fd -IHL --ignore-file ~/.config/fd/index-excludes'; command fd -IHL --ignore-file ~/.config/fd/index-excludes $argv; ...
3	10	--> if set -q _flag_save
        funcsave $name
    ...
7	7	---> set -q _flag_save
47	636	-> alias ll 'lsd -lA --group-dirs=first'
10	10	--> set -l options 'h/help' 's/save'
19	19	--> argparse -n alias --max-args=2 $options -- $argv
3	8	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
5	5	---> set -q _flag_help
6	6	--> set -l name
6	6	--> set -l body
6	6	--> set -l prefix
6	6	--> set -l first_word
6	6	--> set -l wrapped_cmd
10	39	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
5	5	---> not set -q argv[2]
9	9	---> set name $argv[1]
8	8	---> set body $argv[2]
4	20	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
9	9	---> test -z "$name"
7	7	---> test -z "$body"
56	56	--> printf '%s\n' $body | read -lt first_word body
3	15	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
12	12	---> test $first_word = $name
49	71	--> set -l cmd_string (string escape -- "alias $argv")
22	22	---> string escape -- "alias $argv"
73	178	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
105	105	---> string join ' ' -- $first_word $body | string escape
116	132	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
16	16	---> function ll --wraps 'lsd -lA --group-dirs=first' --description 'alias ll lsd -lA --group-dirs=first';  lsd -lA --group-dirs=first $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
56	623	-> alias ls 'lsd -A --group-dirs=first'
12	12	--> set -l options 'h/help' 's/save'
22	22	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
6	6	--> set -l prefix
7	7	--> set -l first_word
7	7	--> set -l wrapped_cmd
13	44	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
5	5	---> not set -q argv[2]
10	10	---> set name $argv[1]
9	9	---> set body $argv[2]
5	23	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
10	10	---> test -z "$name"
8	8	---> test -z "$body"
61	61	--> printf '%s\n' $body | read -lt first_word body
3	16	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
51	78	--> set -l cmd_string (string escape -- "alias $argv")
27	27	---> string escape -- "alias $argv"
56	152	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
96	96	---> string join ' ' -- $first_word $body | string escape
93	106	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
13	13	---> function ls --wraps 'lsd -A --group-dirs=first' --description 'alias ls lsd -A --group-dirs=first';  lsd -A --group-dirs=first $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
55	579	-> alias tree 'ls --tree'
12	12	--> set -l options 'h/help' 's/save'
22	22	--> argparse -n alias --max-args=2 $options -- $argv
3	9	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
6	6	---> set -q _flag_help
7	7	--> set -l name
6	6	--> set -l body
7	7	--> set -l prefix
7	7	--> set -l first_word
8	8	--> set -l wrapped_cmd
11	42	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
6	6	---> not set -q argv[1]
6	6	---> not set -q argv[2]
10	10	---> set name $argv[1]
9	9	---> set body $argv[2]
5	22	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
9	9	---> test -z "$name"
8	8	---> test -z "$body"
50	50	--> printf '%s\n' $body | read -lt first_word body
4	17	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
56	82	--> set -l cmd_string (string escape -- "alias $argv")
26	26	---> string escape -- "alias $argv"
47	121	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
74	74	---> string join ' ' -- $first_word $body | string escape
87	101	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
14	14	---> function tree --wraps 'ls --tree' --description 'alias tree ls --tree';  ls --tree $argv; ...
3	11	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
135	533	-> source ~/.local/omf/pkg/colorman/init.fish
46	65	--> set -x LESS_TERMCAP_md (printf "\e[01;38;5;74m")
19	19	---> printf "\e[01;38;5;74m"
41	58	--> set -x LESS_TERMCAP_mb (printf "\033[01;31m")
17	17	---> printf "\033[01;31m"
39	54	--> set -x LESS_TERMCAP_me (printf "\033[0m")
15	15	---> printf "\033[0m"
39	55	--> set -x LESS_TERMCAP_ue (printf "\e[0m")
16	16	---> printf "\e[0m"
40	57	--> set -x LESS_TERMCAP_us (printf "\e[04;38;5;146m")
17	17	---> printf "\e[04;38;5;146m"
39	54	--> set -x LESS_TERMCAP_se (printf "\033[0m")
15	15	---> printf "\033[0m"
40	55	--> set -x LESS_TERMCAP_so (printf "\033[01;44;33m")
15	15	---> printf "\033[01;44;33m"
99	5213	> repo_metadata -c vim-dart.repo
137	143	-> source /home/impsid/.config/fish/functions/repo_metadata.fish
6	6	--> function repo_metadata
  set options 'n/null' 'c/check'
  argparse -s -x 'n,c' $options -- $argv
  test $status -ne 0; and return 2

  test ! -f $repositories/$argv[1]; and return 1

  set metadata (sed '/^#!/,$d; s/\\\/\\\\\\\\\\\\\\\/g' $repositories/$argv[1])

  if set -q _flag_check
    echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
  else if set -q _flag_null
    echo $metadata | jq -e $argv[3] $argv[2] > /dev/null
  else
    echo $metadata | jq -re $argv[3] $argv[2]
  end

  return $status
...
14	14	-> set options 'n/null' 'c/check'
31	31	-> argparse -s -x 'n,c' $options -- $argv
13	13	-> test $status -ne 0
127	127	-> test ! -f $repositories/$argv[1]
83	1674	-> set metadata (sed '/^#!/,$d; s/\\\/\\\\\\\\\\\\\\\/g' $repositories/$argv[1])
1591	1591	--> sed '/^#!/,$d; s/\\\/\\\\\\\\\\\\\\\/g' $repositories/$argv[1]
24	3080	-> if set -q _flag_check
    echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
  else if set -q _flag_null
    echo $metadata | jq -e $argv[3] $argv[2] > /dev/null
  else
    echo $metadata | jq -re $argv[3] $argv[2]
  ...
9	9	--> set -q _flag_check
3047	3047	--> echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
32	32	-> return $status
 jq -e 'has("repo") and has("type")' &> /dev/null
  else if set -q _flag_null
    echo $metadata | jq -e $argv[3] $argv[2] > /dev/null
  else
    echo $metadata | jq -re $argv[3] $argv[2]
  ...
12	12	--> set -q _flag_check
3566	3566	--> echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
29	29	-> return $status
8	5178	--> echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
20	20	-> return $status
ull
  else if set -q _flag_null
    echo $metadata | jq -e $argv[3] $argv[2] > /dev/null
  else
    echo $metadata | jq -re $argv[3] $argv[2]
  ...
12	12	--> set -q _flag_check
5218	5218	--> echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
54	54	-> return $status
 $argv[2]
  ...
14	14	--> set -q _flag_check
3824	3824	--> echo $metadata | jq -e 'has("repo") and has("type")' &> /dev/null
28	28	-> return $status
turn $status
